{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Distopia","text":"<p>Distopia is a package to rapidly calculate distances, angles and dihedrals under periodic boundary conditions in single and double precision. Explicit SIMD vectorisation allows awesome speedups over autovectorised code (up to 10x). The distopia package consists of consists of the python layer (distopia) and a C++ library (libdistopia) that does the heavy lifting.</p> <p>Distopia can be used out of the box by building the library using the instructions in Building and Testing. Examples of use are given in Examples.</p>"},{"location":"#current-status","title":"Current Status","text":"<p>Distopia is currently under active development and should be considered alpha This means the API is liable to change rapidly without warning.</p>"},{"location":"#os-and-compiler-support","title":"OS and compiler support","text":"<p>We currently support x86_64 and ARM with the Clang and GCC family of compilers. Windows and MSVC probably work, but are not tested in CI, so use at your own risk. </p>"},{"location":"#participating","title":"Participating","text":"<p>Ask questions on the mdnalysis-discussion mailing list and be part of the conversation. You can also join the MDAnalysis Discord Server to talk with other users and developers. In order to join our Discord server, use the following invitation. Please report bugs or enhancement requests through the Issue Tracker. Distopia is open source and welcomes your contributions. Fork the repository on GitHub and submit a pull request!</p>"},{"location":"api/","title":"API documentation","text":""},{"location":"api/#api-documentation-for-the-distopia-python-layer","title":"API documentation for the <code>distopia</code> python layer","text":"<code>distopia.distances_no_box</code>(coords0, coords1, results=None) <p>distances_no_box(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate pairwise distances between coords0 and coords1 with no periodic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and same dtype\nresults: float32 of float 64 array (optional)\n  array to store results in, must be same size and dtype as coords0/coords1\n\nReturns\n-------\ndistances : np.array\n  same length and dtype as coords0/coords1\n</code></pre> <code>distopia.distances_ortho</code>(coords0, coords1, box, results=None) <p>distances_ortho(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate pairwise distances between coords0 and coords1 under orthorhombic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n  orthorhombic periodic boundary dimensions in [L, L, L] format\nresults: float32 or float64 array (optional)\n  array to store results in, must be same length and dtype as coords0/coords1\n\nReturns\n-------\ndistances : np.array\n  same length and dtype as coords0/coords1\n</code></pre> <code>distopia.distances_triclinic</code>(coords0, coords1, box, results=None) <p>distances_triclinic(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate pairwise distances between coords0 and coords1 under triclinic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n  periodic boundary dimensions, in 3x3 format\nresults: float32 or float64 array (optional)\n  array to store results in, must be same length and dtype as coords0/coords1\n\nReturns\n-------\ndistances : np.array\n  same length and dtype as coords0/coords1\n</code></pre> <code>distopia.angles_no_box</code>(coords0, coords1, coords2, results=None) <p>angles_no_box(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate angles between sets of coordinates with no periodic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1, coords2 : float32 or float64 array\n  must be same length and dtype\nresults: float32 or float64 array (optional)\n    array to store results in, must be same length and dtype as coords0/coords1/coords2\n\nReturns\n-------\nangles : np.array\n  same length and dtype as coords0/coords1/coords2\n</code></pre> <code>distopia.angles_ortho</code>(coords0, coords1, coords2, box, results=None) <p>angles_ortho(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate angles between sets of coordinates under orthorhombic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1, coords2 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    orthorhombic periodic boundary dimensions in [L, L, L] format\nresults: float32 or float64 array (optional)\n    array to store results in, must be same length and dtype as coords0/coords1/coords2\n\nReturns\n-------\nangles : np.array\n  same length and dtype as coords0/coords1/coords2\n</code></pre> <code>distopia.angles_triclinic</code>(coords0, coords1, coords2, box, results=None) <p>angles_triclinic(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate angles between sets of coordinates under triclinic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1, coords2 : float32 or float64 array\n    must be same length and dtype\nbox : float32 or float64 array\n    periodic boundary dimensions, in 3x3 format\nresults: float32 or float64 array (optional)\n    array to store results in, must be same length and dtype as coords0/coords1/coords2\n\nReturns\n-------\nangles : np.array\n    same length and dtype as coords0/coords1/coords2\n</code></pre> <code>distopia.dihedrals_no_box</code>(coords0, coords1, coords2, coords3, results=None) <p>dihedrals_no_box(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate dihedral angles between sets of coordinates with no periodic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1, coords2, coords3 : float32 or float64 array\n  must be same length and dtype\nresults: float32 or float64 array (optional)\n    array to store results in, must be same length and dtype as coords0/coords1/coords2/coords3\n\nReturns\n-------\ndihedrals : np.array\n  same length and dtype as coords0/coords1/coords2/coords3\n</code></pre> <code>distopia.dihedrals_ortho</code>(coords0, coords1, coords2, coords3, box, results=None) <p>dihedrals_ortho(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate dihedral angles between sets of coordinates under orthorhombic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1, coords2, coords3 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    orthorhombic periodic boundary dimensions in [L, L, L] format\nresults: float32 or float64 array (optional)\n    array to store results in, must be same length and dtype as coords0/coords1/coords2/coords3\n\nReturns\n-------\ndihedrals : np.array\n  same length and dtype as coords0/coords1/coords2/coords3\n</code></pre> <code>distopia.dihedrals_triclinic</code>(coords0, coords1, coords2, coords3, box, results=None) <p>dihedrals_triclinic(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate dihedral angles between sets of coordinates under triclinic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1, coords2, coords3 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    periodic boundary dimensions, in 3x3 format\nresults: float32 or float64 array (optional)\n    array to store results in, must be same length and dtype as coords0/coords1/coords2/coords3\n\nReturns\n-------\ndihedrals : np.array\n  same length and dtype as coords0/coords1/coords2/coords3\n</code></pre> <code>distopia.distance_array_no_box</code>(coords0, coords1, results=None) <p>distance_array_no_box(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate pairwise distance matrix between coordinates with no periodic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and dtype\nresults: float32 or float64 array (optional)\n    array to store results in, must be of length MxN where M is the length of coords0 and N is the length of coords1\n\nReturns\n-------\ndistances : np.array\n  MxN array of distances\n</code></pre> <code>distopia.distance_array_ortho</code>(coords0, coords1, box, results=None) <p>distance_array_ortho(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate pairwise distance matrix between coordinates under orthorhombic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    orthorhombic periodic boundary dimensions in [L, L, L] format\nresults: float32 or float64 array (optional)\n    array to store results in, must be  of length MxN where M is the length of coords0 and N is the length of coords1\n\nReturns\n-------\ndistances : np.array\n  MxN array of distances\n</code></pre> <code>distopia.distance_array_triclinic</code>(coords0, coords1, box, results=None) <p>distance_array_triclinic(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate pairwise distance matrix between coordinates under triclinic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    periodic boundary dimensions, in 3x3 format\nresults: float32 or float64 array (optional)\n    array to store results in, must be of length MxN where M is the length of coords0 and N is the length of coords1\n\nReturns\n-------\ndistances : np.array\n  MxN array of distances\n</code></pre> <code>distopia.self_distance_array_no_box</code>(coords0, results=None) <p>self_distance_array_no_box(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate self-pairwise distance matrix between coordinates with no periodic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, float32 or float64 array\n  must be same length and dtype\nresults: float32 or float64 array (optional)\n    array to store results in, must be a single dimension of length N(N-1)/2 where N is the length of coords0\n\nReturns\n-------\ndistances : np.array\n  N(N-1)/2 array of distances, a flattened upper triangle of the full NxN matrix with the diagonal removed\n</code></pre> <code>distopia.self_distance_array_ortho</code>(coords0, box, results=None) <p>self_distance_array_ortho(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate self-pairwise distance matrix between coordinates under orthorhombic periodic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0: float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    periodic boundary dimensions, in 3x3 format\nresults: float32 or float64 array (optional)\n    array to store results in, must be a single dimension of length N(N-1)/2 where N is the length of coords0\n\nReturns\n-------\ndistances : np.array\n  N(N-1)/2 array of distances, a flattened upper triangle of the full NxN matrix with the diagonal removed\n</code></pre> <code>distopia.self_distance_array_triclinic</code>(coords0, box, results=None) <p>self_distance_array_triclinic(signatures, args, kwargs, defaults, _fused_sigindex={}) ulate self-pairwise distance matrix between coordinates under triclinic boundary conditions</p> <pre><code>Parameters\n----------\ncoords0, coords1 : float32 or float64 array\n  must be same length and dtype\nbox : float32 or float64 array\n    periodic boundary dimensions, in 3x3 format\nresults: float32 or float64 array (optional)\n    array to store results in, must be a single dimension of length NxN where M is the length of coords0\n\nReturns\n-------\ndistances : np.array\n  N*(N-1)/2 array of distances, a flattened upper triangle of the full NxN matrix with the diagonal removed\n</code></pre>"},{"location":"building_and_testing/","title":"Building and testing","text":""},{"location":"building_and_testing/#building","title":"Building","text":"<p>Distopia uses the scikit-build build system. You can build the library easily by first installing the prerequisites.</p> <pre><code>mamba env create --file devtools/conda_envs/distopia_&lt;platform&gt;-latest.yaml\nmamba activate distopia\npip install . \n</code></pre> <p>If you want greater control over build and install options you can do a more manual install specifying CMake args like so:</p> <pre><code>python setup.py install -- -DCMAKE_BUILD_TYPE=Release &lt;etc etc&gt;\n</code></pre>"},{"location":"building_and_testing/#testing","title":"Testing","text":"<p>Testing for distopia is done on two levels. The <code>distopia</code> python layer has <code>pytest</code> tests you can run after installing the package.</p> <pre><code>pip install pytest\ncd distopia/tests\npytest -vvv \n</code></pre> <p>Testing for the <code>libdistopia</code> C++ layer is done with <code>googletest</code> executables. First do a build of the package, then use <code>ctest</code> to execute the relevant binaries in <code>_skbuild/&lt;platform&gt;/cmake-build/libdistopia</code>. Alternatively you can execute the binaries directly.</p> <pre><code>python setup.py build\nctest --test-dir _skbuild/*/cmake-build/libdistopia\n</code></pre>"},{"location":"building_and_testing/#benchmarking","title":"Benchmarking","text":"<p>Automated benchmarks for <code>libdistopia</code> are available, written using <code>googlebench</code>. Similarly to testing first do a build of the library, and then execute the benchmarking binary.</p> <pre><code>python setup.py build\ncd _skbuild/&lt;platform&gt;/cmake-build/libdistopia\n./bench\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Distopia aims to be a small and simple library for calculating kernels common in analysis of molecular simulations. </p> <p>Simple examples of use are given below. </p>"},{"location":"examples/#distances","title":"Distances","text":"<p>First we construct some random coordinates using numpy and calculate distances between them without periodic boundary conditions using <code>distopia</code>. You can use <code>np.float32</code> for single precision and <code>np.float64</code> for double precision. </p>"},{"location":"examples/#no-periodic-boundary-conditions","title":"No periodic boundary conditions","text":"<pre><code>import numpy as np\nimport distopia\n\n# make N x 3 coordinate arrays\nN = 10000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates1 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\nresult = distopia.distances_no_box(coordinates0, coordinates1)\n\n# alternatively we can pass in a buffer to use for the results.\nbuffer = np.empty(N, dtype=np.float32)\nresult = distopia.distances_no_box(coordinates0, coordinates1, results=buffer)\n</code></pre>"},{"location":"examples/#orthorhombic-periodic-boundary-conditions","title":"Orthorhombic periodic boundary conditions","text":"<p>Using periodic boundary conditions is very similar. For orthorhombic boxes you only need to provide the three box vector lengths <code>[l, l, l]</code></p> <pre><code>import numpy as np\nimport distopia\n\n# make N x 3 coordinate arrays\nN = 10000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates1 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\nbox = np.asarray([10, 10, 10]).astype(np.float32)\nresult = distopia.distances_ortho(coordinates0, coordinates1, box)\n</code></pre>"},{"location":"examples/#triclinic-periodic-boundary-conditions","title":"Triclinic periodic boundary conditions","text":"<p>For triclinic boxes the box matrix must be provided in 3x3 matrix form. </p> <pre><code>import numpy as np\nimport distopia\n\nN = 10000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates1 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\nbox = np.asarray([[10, 0, 0], [0, 10, 0], [0, 0, 10]]).astype(np.float32)\nresult = distopia.distances_triclinic(coordinates0, coordinates1, box)\n</code></pre>"},{"location":"examples/#note","title":"Note","text":"<p>All of the below functions also support orthorhombic and triclinic systems within the same function naming convention but the no-pbc versions are used for demonstration purposes. See the API docs for more details.</p>"},{"location":"examples/#angles","title":"Angles","text":"<p>Angles function in a similar way to distances, but requiring one more coordinate. </p> <pre><code>import numpy as np\nimport distopia\n\n# make N x 3 coordinate arrays\nN = 10000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates1 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates2 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\nresult = distopia.angles_no_box(coordinates0, coordinates1, coordinates2)\n</code></pre>"},{"location":"examples/#dihedrals","title":"Dihedrals","text":"<p>Dihedrals require 4 coordinates </p> <pre><code>import numpy as np\nimport distopia\n\n# make N x 3 coordinate arrays\nN = 10000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates1 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates2 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates3 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\nresult = distopia.dihedrals_no_box(coordinates0, coordinates1, coordinates2, coordinates3)\n</code></pre>"},{"location":"examples/#distance-arrays","title":"Distance arrays","text":"<p>You can also do pairwise and self-pairwise distance arrays with <code>distopia</code>. </p>"},{"location":"examples/#pairwise-distances","title":"Pairwise distances","text":"<pre><code>import numpy as np\nimport distopia\n\n# make N x 3 and M x 3 coordinate arrays\nN = 10000\nM = 1000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\ncoordinates1 = np.random.rand(3 * M).reshape(M, 3).astype(np.float32)\nresult = distopia.distance_array_no_box(coordinates0, coordinates1)\nresult # -&gt; will be NxM\n\n# passing in a result buffer is also possible for distance arrays \nbuffer = np.empty((N,M), dtype=np.float32)\nresult = distopia.distance_array_no_box(coordinates0, coordinates1, results=buffer)\n</code></pre>"},{"location":"examples/#self-pairwise-distances","title":"Self-pairwise distances","text":"<p>Self distance arrays are similar but use only a single coordinate producing an N*(N-1)/2 array of distances, a flattened upper triangle of the full NxN matrix with the diagonal removed.</p> <pre><code>import numpy as np\nimport distopia\n\n# make N x 3 coordinate array\nN = 10000\ncoordinates0 = np.random.rand(3 * N).reshape(N, 3).astype(np.float32)\nresult = distopia.self_distance_array_no_box(coordinates0)\nresult # -&gt; will be NxN with result\n</code></pre> <p>To recover the full NxN matrix use the following</p> <pre><code>distance_matrix = np.zeros((N,N))\nk = 0\nfor i in range(N):\n    for j in range(i + 1, N):\n        distance_matrix[i, j] = result[k]\n        k += 1\n</code></pre>"},{"location":"examples/#questions","title":"Questions","text":"<p>Please raise any questions or issues on the issue tracker. </p>"}]}